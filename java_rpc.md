## 简易rpc框架

跟着教程造一个简易轮子

<!--more-->

RPC, Remote Procedur0e Call ,远程过程调用, 它是一个计算机通信协议。**它允许像调用本地服务一样调用远程服务**。它可以有不同的实现方式。如RMI(远程方法调用)、Hessian、Http invoker等。另外，RPC是与语言无关的。

允许一台计算机调用另一台计算机上的程序得到结果, 代码中不需要额外的编程, 像在本地调用一样 ，让调用者感觉不到远程调用的逻辑

分布式的应用可以借助RPC来完成 机器之间的调用 

解决分布式系统中服务之间的调用wen'ti

## **RPC框架原理**

在RPC框架中主要有三个角色：Provider、Consumer和Registry

节点角色说明： 
\* Server: 暴露服务的服务提供方。 
\* Client: 调用远程服务的服务消费方。 
\* Registry: 服务注册与发现的注册中心。

![img](../images/java_rpc/522490-20151003120412386-363334260.png)

即将开始记录 

## 基于技术

序列化和反序列化,  Java CompletableFuture  (序列化: 将对象转为字节流 )

Netty(异步NIO) 实现服务器(通过socket绑定ip和port)

### socket

socket把 TCP/IP 协议层的各种数据封装, 数据发送, 接收等通过代码封装好, 只需要调用, 就可实现机器间的通信 

socket 的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。

我们把插头插到插座上就能从电网获得电力供应，同样，为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。

![socket是什么？](../images/java_rpc/1-1Z1231A00X07.jpg)

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。

在设计模式中，Socket其实就是一个门面模式，**它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。**

![img](../images/java_rpc/1447456-20180916104632687-218367783.png)

#### 编写Socket套接字的流程

![img](../images/java_rpc/1447456-20180916110843626-688018029.png)

1、服务器端程序的编写步骤：

（1）创建调用socket()函数创建一个用于通信的套接字。#phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

（2）s.bind() 绑定(主机,端口号)到套接字。 #phone.bind(('127.0.0.1',8080))

（3）s.listen() 开始TCP监听 。#phone.listen(5)# 5 代表最多挂机数

（4）s.accept() 被动接受TCP客户的连接,(阻塞式)等待连接的到来。# conn,client_addr = phone.accept()

（5）处理客户端的连接请求。 **# 1、s.recv() 接收数据 /data = conn.recv(1024) # 2、反馈给客户端：s.send() 发送数据**

（6）关闭套接字/ s.send() 发送数据

2、客户端程序的编写步骤：

（1）调用socket()函数创建一个用于通信的套接字。# phone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

（2）s.connect() 主动初始化TCP服务器连接 # phone.connect(('127.0.0.1',8080))

（3）调用读写函数发送或者接收数据。# s.send() 发送数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完，可后面通过实例解释)

例如：phone.send('hello'.encode('utf-8'))

（4）接受服务端的反馈信息： s.recv() 接收数据 # 例如：
data = phone.recv(1024)
       （5）关闭sokect

#### 服务器, 客户端交互流程图

![img](../images/java_rpc/1447456-20180916114942455-1548402751.png)

### Netty

使用Netty作为网络通信层 ,Netty能够通过编程自定义各种协议 

### Protobuf

Goole的序列化框架，具有良好的可扩展性。 

优点：序列化的结果体积比XML、JSON小很多，XML和JSON的描述信息太多了，导致消息要大；此外Portobuf还使用了Varint 编码，减少数据对空间的占用。

Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。

### 代理

调用方调用由动态代理接收

由动态代理想办法调用远程的实际实现，包括下面几步

- 识别具体要调用的远程方法的IP、端口
- 将调用方法的入参进行序列化
- 通过通信将请求发送到远程的方法中

这样，远程的服务就接收到了调用方的请求。它应该：

- 反序列化各个调用参数
- 定位到实际要调用的方法，然后输入参数，执行方法
- 按照调用的路径返回调用的结果

![img](../images/java_rpc/webp.webp)

### 关于gRPC使用http2作为连接支持

在了解 HTTP/2 之前，需要知道一些通用术语：

- Stream： 一个双向流，一条连接可以有多个 streams。
- Message： 也就是逻辑上面的 request，response。
- Frame:：数据传输的最小单位。每个 Frame 都属于一个特定的 stream 或者整个连接。一个 message 可能有多个 frame 组成。

下图是gRPC语义与HTTP/2的关系： 

![img](../images/java_rpc/Screen-Shot-2018-08-27-at-10.41.00-AM.jpg)

通道是 gRPC 中的一个关键概念。HTTP/2 中的流支持在单个连接上进行多个并发会话；通道通过在多个并发连接上启用多个流来扩展这个概念。从表面上看，频道为用户发送消息提供了一个简单的界面；然而，在引擎盖下，大量的工程投入到保持这些连接的活力、健康和利用上。

通道代表到端点的虚拟连接，实际上可能由许多 HTTP/2 连接支持。RPC 与连接相关联（此关联将在后面进一步描述）。RPC 实际上是普通的 HTTP/2 流。消息与 RPC 相关联并作为 [HTTP/2 数据帧](https://http2.github.io/http2-spec/#rfc.figure.6)发送。更具体地说，消息是 在数据帧之上*分层 的。*一个数据帧可能有许多 gRPC 消息，或者如果一个 gRPC 消息非常大 (2)，它可能跨越多个数据帧。

### 其余更多原理等

[参考](https://www.cnblogs.com/foremostxl/p/9655716.html)

## 设计思路(这里实现基于他人设计思路和设计流程)

让客户端调用服务端方法就像调用本地方法一样简单的框架

一个最简单的rpc框架使用示意图

![image-20210706225809082](../images/java_rpc/image-20210706225809082.png)

服务提供端Server向注册中心注册服务, 服务消费者Clien通过注册中心拿到服务相关信息,然后再通过网络请求服务提供段Server

![image-20210706230407214](../images/java_rpc/image-20210706230407214.png)

1. **注册中心** ：注册中心首先是要有的，推荐使用 Zookeeper。注册中心负责服务地址的注册与查找，相当于目录服务。服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。
2. **网络传输** ：既然要调用远程的方法就要发请求，请求中至少要包含你调用的类名、方法名以及相关参数吧！推荐基于 NIO 的 Netty 框架。
3. **序列化** ：既然涉及到网络传输就一定涉及到序列化，你不可能直接使用 JDK 自带的序列化吧！JDK 自带的序列化效率低并且有安全漏洞。 所以，你还要考虑使用哪种序列化协议，比较常用的有 hession2、kyro、protostuff。
4. **动态代理** ： 另外，动态代理也是需要的。因为 RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，使用动态代理可以屏蔽远程方法调用的细节比如网络传输。也就是说当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法呢？
5. **负载均衡** ：负载均衡也是需要的。为啥？举个例子我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。
6. ......

### 字节编码器和解码器

使用byte类型进行数据的转换 

通过扩展MessageToByteEncoder 来进一步实现编码器(Encoder)功能 

### @SPI

自定义SPI , 通过 ExtensionLoader 来实现对应功能对应的实现类的实例化

扩展功能在相应的接口定义处加上 @SPI 注解, 一般加在接口之上 ,由 SPI寻找对应的实现类

ExtensionLoader 实例对应功能时在内部通过name在所有功能中进行筛选,再进行实例化

## 关于远程调用使用rpc

分布式系统中，每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。

要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。

但HTTP也有其缺点。 首先是有用信息占比少，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是效率低，还是因为第七层的缘故。还有，其可读性似乎没有必要，因为我们可以引入网关增加可读性。此外，使用HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值。

服务A调用服务B的过程是应用间的内部过程，牺牲可读性提升***`效率、易用性`***是可取的。基于这种思路，RPC产生了  

远程调用的操作通过动态代理完成，使用tcp或者udp作为通讯协议负责为动态代理传输调用方法请求和参数，也可以使用HTTP

另一方面来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性。可以这么理解，[rpc框架](https://www.zhihu.com/search?q=rpc框架&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A191965937})是面向服务的更高级的封装。 如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。

良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。
