# 学习Redis

<!-- more -->

## 用作分布式缓存

因为Redis 中的数据 存放在内存中 , 所以可以将Redis 作为程序与数据库直接交互的中间商 

即业务层 和 数据访问层之间的一个 "临时仓库" ,  使用sql语句直接操纵数据库是一项比较耗时的工作,  如果有大规模的用户向数据库传递更改数据的请求, 将会造成数据库连接问题. 比如门就那么大 , 做多只能同时进两个人,你非要进四个. 
redis 可以作为临时存放 用户请求的地方, 将请求分批次去传输到数据库, 在这里可以直接先返回一定的结果, 因为用户请求会因为网速等原因分先后, 

这里也涉及到 Redis的内部工作机制     同时使用Redis 的常见问题 有

- 缓存和数据库双写一致性问题
- 缓存雪崩问题
- 缓存击穿问题
- 缓存的并发竞争问题

### Redis 内部机制

Redis为单线程操作 

操作方式主要有以下三点: 

1. 纯内存操作

2. 单线程操作, 避免了频繁的上下文切换

3. 采用了非阻塞I/O多路复用机制 
   
   这里说一下 I/O多路复用机制

### 本地缓存

### 分布式缓存

### 多级缓存

## 

#### I/O多路复用机制

传统的并发模型 会将每个 I/O 流中的操作分配给一个新的线程管理, 线程的创建需要得到CPU得允许,或者说 线程在工作时需要得到CPU的空间, CPU 根据自身的固件上的芯片, 也即 CPU核数去同时执行基于核数的线程操作, 这里涉及到线程数和CPU同时处理任务数的关系 

简单的来说就是比如 1核单cpu(不涉及当前多核cpu和超线程模式) , 同一时间只能执行一个线程 ,

有 I/O 流工作 A , B .  A 先到, B后到,  thread A  负责A ,  thread B 负责B , thread B要等thread A完成工作A后 再向CPU申请资源区完成B

这样导致线程过多但资源不够,如果同时间有 thread B 和thread C 同时等待A的工作完成, 将会造成竞争, 会增加时间

 I/O 多路复用, 完成多个工作, 只有一个线程  A

thread A通过跟踪每个I/O流的状态 , 也就是任务的工作内容, 地点 ,来管理多个I/O流

一下为Redis线程模型 

![img](../images/Redis/v2-8be3d5948f178144a83eec26e2fa2ab6_720w.jpg)

Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。String

最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。

五种数据类型

Hash

这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。

List

使用 List 的数据结构，可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。

Set

因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。我们的系统一般都是集群部署，使用 JVM 自带的 Set 比较麻烦。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

Sorted Set

Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。

## Redis 单线程模型详解

Redis基于Reactor模式来设计开发了自己的一起额高效的事件处理模型(Netty的线程模型也基于Reactor模式 ,Reactor模式不愧是高性能IO的基石) ，这套事件处理模型对应的是Redis中的文件事件处理器（file event handler）。由于文件事件处理器是单线程运行的， 所以我们一般都说Redis是单线程模型

![image-20210606225215733](../images/Redis/image-20210606225215733.png)

《Redis 设计与实现》有一段话是如是介绍文件事件的

> Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。
> 
> 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
> 
> **虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。还是单线程处理 

Redis 6.0 之前使用单线程 主要原因大概有下面3个: 

1. 单线编程容易并且更容易维护 

2. Redis 的性能瓶颈不在CPU, 主要在内存和网络 

3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能

## springboot 中使用  Redis 作为缓存

### 可以定义Reids工具类封装JedisTem

定义工具类封装 redis 中操作redis存储的对象 

## 缓存设置过期时间

一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？

因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。

Redis 自带了给缓存数据设置过期时间的功能，比如：

```bash
127.0.0.1:6379> exp key  60 # 数据在 60s 后过期
(integer) 1
127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)
OK
127.0.0.1:6379> ttl key # 查看数据还有多久过期
(integer) 56Copy to clipboardErrorCopied
```

注意：**Redis 中除了字符串类型有自己独有设置过期时间的命令 `setex` 外，其他方法都需要依靠 `expire` 命令来设置过期时间 。另外， `persist` 命令可以移除一个键的过期时间： **

**过期时间除了有助于缓解内存的消耗，还有什么其他用么？**

很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。

如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。

## Redis 是如何判断数据是否过期的

Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。

![image-20210607115909391](../images/Redis/image-20210607115909391.png)

过期字典是存储在redisDb这个结构里的 

```
typedef struct redisDb{
    ... 

    dict *dict;
    dict *expires; 
} redisDb;
```

## 过期数据删除策略

常用的两个过期数据删除策略 (自己造缓存轮子的时候需要格外考虑的东西):

1. 惰性删除 : 只会在取出key的时候才对数据进行过去过期检查, 这样对CPU 最友好, 但是可能会造成太多过期 key 没有被删除 
2. 定期删除: 每隔一段时间抽取一批key执行删除过期key 操作. 并且 Redis 底层会通过限制删除操作执行的时长和频率来减少对CPU时间的影响 

定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 **定期删除+惰性/懒汉式删除** 。

但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。

怎么解决这个问题呢？答案就是： **Redis 内存淘汰机制。**

## Redis 内存淘汰机制

Redis 提供6种数据淘汰策略 : 

1. **volatile-lru（least recently used）**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：

1. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu（least frequently used）**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## Redis 持久化机制 ( Redis挂掉之后再重启数据可以进行恢复)

快照(Snapshotting, RDB) 

只追加文件(append-only file , AOF ) 

### 快照

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：

```conf
save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照
```

### AOF持久化

与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：

```conf
appendonly yesCopy to clipboardErrorCopied
```

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```conf
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步Copy to clipboardErrorCopied
```

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

**相关 issue** ：[783：Redis 的 AOF 方式](https://github.com/Snailclimb/JavaGuide/issues/783)

**拓展：Redis 4.0 对于持久化机制的优化**

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

**补充内容：AOF 重写**

AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。

在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作

### Redis的AOF方式

当磁盘无法满足写入速度，并且后台 `fsync(2)` 调用花费的时间超过 1 秒时，那么 `Redis` 可能会将该次 `AOF` 写入操作延迟最多一秒钟后执行（延迟是为了避免该写入操作会阻塞主线程，因为 `fsync(2)` 在后台线程是针对同一文件描述符运行的)。但是如果 `fsync(2)` 在这两秒内都没有正常执行完，那么 `Redis` 最终将强行执行（可能阻塞）`write(2)` 函数以将数据正确的传输到磁盘。

例如在 00:00 的时候，`Redis` 在 `everysec` 策略下，此时需要执行 `AOF` （`fsync` 函数）。但是在这 00:00 时刻，服务器上的另一个应用程序有大量写入的操作占用了当前磁盘的写入缓冲区。那么在这一秒，`fsync` 函数可能会超时失败（如果没有超时设置，那么在这 00:00，服务器上的磁盘大量写入，导致服务器所有应用（包括 `Redis` 自己）会导致主线程的写入阻塞）。`Redis` 为了优雅的解决这个问题，当 `fsync` 函数执行超时失败时，会使用延迟写入策略：会在 00:01 的时候写入本该 00:00 写入的文件（但是这种情况下出现异常，会导致 2s 的数据丢失？），如果在 00:01 的时候写入操作都执行超时，那么 `Redis` 会强行执行 `write(2)` 函数。
