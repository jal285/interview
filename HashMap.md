# 关于hashmap的面试题

<!--more-->

[参考](https://mp.weixin.qq.com/s?__biz=MzUzMjUzMzI0NA==&mid=2247487731&idx=1&sn=56fef38cf9a5a24c2e4a094741e6827b&chksm=fab08a60cdc70376b522bef1fba393a5838366e0a8f69a1e108078154d4f26e449acfcd96670&mpshare=1&scene=23&srcid=1101hEDU9RcunrNBYtEocZyL&sharer_sharetime=1635764681900&sharer_shareid=8898e746b0f249ecdba4fe363392aada#rd)

## HashMap的数据结构

哈希表结构(链表散列: 数组+链表) 实现, 结合数组和链表的优点. 当链表长度超过8时, 链表转换为红黑树 

```java
transient Node<K,V>[] table;
```

## HashMap的工作原理

HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put & get 方法存储和获取。

**存储对象时，将 K/V 键值传给 put() 方法：**
**1、**调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；
**2、**调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；
**3、**如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；

如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；
如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）。

**获取对象时，将 K 传给 get() 方法：**
**1、**调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；

2、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。

hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等。

## 当两个对象的hashCode相同

hashcode相同, 不一定就是相等的(equals方法比较) ,所以两个对象所在下标相同, 发生"碰撞" ,又因为hashmap使用链表存储对象, 这个Node回存储到链表中

### 哈希碰撞是什么

所谓哈希（hash），就是将不同的输入映射成独一无二的、固定长度的值（又称"哈希值"）。它是最常见的软件运算之一。

如果不同的输入得到了同一个哈希值，就发生了"哈希碰撞"（collision）

![img](../images/HashMap/bg2018090510.png)

发生碰撞后将会被视为同一个元素

两个不同的用户得到了相同的哈希值就会发生"碰撞" , 会被服务器视为同一个人, 意味着用户B可以更改用户A的信息

## hash的实现

JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。

## 使用异或运算符的原因

保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。

## HashMap的table的容量如何确定? loadFactor是什么, 该容量如何变化? 这种变化会带来什么问题

**1、**table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30；

**2、**loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；

**3、**扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）；

**4、**如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。

### HashMap中put方法的过程

答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；
**1、**如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
**2、**如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
**3、**如果结点的key已经存在，则替换其value即可；
**4、**如果集合中的键值对大于12，调用resize方法进行数组扩容。”

### 数组扩容的过程

创建一个新的数组, 其容量为旧数组的两倍, 并重新计算就数组中节点的存储位置

结点在新数组中的位置只有两种, 原下标位置+旧数组的大小 

### 拉链法导致的链表过深问题为什么不用二叉查找树替代, 而选择红黑树, 为什么不一直使用红黑树

之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。

而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
