# 关于消息队列

消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ

<!--more-->

## 应用场景

其通用的使用场景可以简单地描述为： 

> 当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。

异步处理，应用解耦，流量削锋和消息通讯四个场景。[参考](https://zhuanlan.zhihu.com/p/45164861)

当前使用较多的消息队列有RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，而部分数据库如[Redis](https://cloud.tencent.com/product/crs?from=10680)、Mysql以及phxsql也可实现消息队列的功能。

- 应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；
- 异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；
- 限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；
- 消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；

### 异步处理

场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式

a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-066e779a575b50f59f4d89557d678842_720w.jpg)

b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-8ad4dcbceb6a89bd47a756801da36e8b_720w.jpg)

设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。

因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）

小结：如以上案例描述，传统的方式系统的性能（并发量，吞吐量，响应时间）会有瓶颈。如何解决这个问题呢？    引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下：

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-fa7bbe7c36f4e622a656a9a3a5016e1e_720w.jpg)

按照以上约定，用户的响应时间相当于是注册信息写入数据库的时间，也就是50毫秒。注册邮件，发送短信写入消息队列后，直接返回，因此写入消息队列的速度很快，基本可以忽略，因此用户的响应时间可能是50毫秒。因此架构改变后，系统的吞吐量提高到每秒20 QPS。比串行提高了3倍，比并行提高了两倍。

### 应用解耦

​    

场景说明：用户下单后，订单系统需要通知库存系统。传统的做法是，订单系统调用库存系统的接口。如下图：

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-87a9e272b4ae825cc3e1d79125f4a26a_720w.jpg)

传统模式的缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统与库存系统耦合

如何解决以上问题呢？引入应用消息队列后的方案，如下图：

​        ![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-699d6bab7d9ae64f6a68989615fdc673_720w.jpg)

订单系统: 用户下单后,订单系统完成持久化处理, 将消息写入消息对列, 返回用户下单成功

库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作

假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦

### 流量削峰

​    流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。

应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要在应用前端加入消息队列。

a、可以控制活动的人数

b、可以缓解短时间内高流量压垮应用

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-fdc804bb47c1592ad391dc2c37d182e9_720w.jpg)

用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。

秒杀业务根据消息队列中的请求信息，再做后续处理

### 日志处理

日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-780bfeeaed627769bfa991ee610427fb_720w.jpg)

日志采集客户端，负责日志数据采集，定时写受写入Kafka队列

Kafka消息队列，负责日志数据的接收，存储和转发

日志处理应用：订阅并消费kafka队列中的日志数据

### 消息通讯

消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等

点对点通讯：![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-9db5dbb9b5412aaecd2fd7052bd768d8_720w.jpg)

客户端A和客户端B使用同一队列，进行消息通讯。

聊天室通讯：

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-d185480ed77b2c7efe601dc3c4e69b7b_720w.jpg)

客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。

以上实际是消息队列的两种消息模式，点对点或发布订阅模式。模型为示意图，供参考。

### 消息中间件实例

#### 电商系统

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-7de596284ead4b36b09d8f60a2159d5c_720w.jpg)

消息队列采用高可用，可持久化的消息中间件。比如Active MQ，Rabbit MQ，Rocket Mq。

（1）应用将主干逻辑处理完成后，写入消息队列。消息发送是否成功可以开启消息的确认模式。（消息队列返回消息接收成功状态后，应用再返回，这样保障消息的完整性）

（2）扩展流程（发短信，配送处理）订阅队列消息。采用推或拉的方式获取消息并处理。

（3）消息将应用解耦的同时，带来了数据一致性问题，可以采用最终一致性方式解决。比如主数据写入数据库，扩展应用根据消息队列，并结合数据库方式实现基于消息队列的后续处理。

#### 日志收集系统

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/v2-c9f452b1c8488b1a3a5e84ce1c604bb7_720w.jpg)

分为Zookeeper注册中心，日志收集客户端，Kafka集群和Storm集群（OtherApp）四部分组成。

Zookeeper注册中心，提出负载均衡和地址查×××

日志收集客户端，用于采集应用系统的日志，并将数据推送到kafka队列

Kafka集群：接收，路由，存储，转发等消息处理

Storm集群：与OtherApp处于同一级别，采用拉的方式消费队列中的数据

## MQ选型对比文档

![img](../images/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/412889-20170813171322179-1790449895.png)

[参考](https://www.cnblogs.com/wlsblog/p/7354038.html)

RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。

Kafka是linkedin开源的MQ系统，主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，0.8开始支持复制，不支持事务，适合产生大量数据的互联网服务的数据收集业务。

ZeroMQ只是一个网络编程的Pattern库，将常见的网络请求形式（分组管理，链接管理，发布订阅等）模式化、组件化，简而言之socket之上、MQ之下。对于MQ来说，网络传输只是它的一部分，更多需要处理的是消息存储、路由、Broker服务发现和查找、事务、消费模式（ack、重投等）、集群服务等。

在面向服务架构中通过消息代理（比如 RabbitMQ / Kafka等），使用生产者-消费者模式在服务间进行异步通信是一种比较好的思想。

因为服务间依赖由强耦合变成了松耦合。消息代理都会提供持久化机制，在消费者负载高或者掉线的情况下会把消息保存起来，不会丢失。就是说生产者和消费者不需要同时在线，这是传统的请求-应答模式比较难做到的，需要一个中间件来专门做这件事。其次消息代理可以根据消息本身做简单的路由策略，消费者可以根据这个来做负载均衡，业务分离等。

缺点也有，就是需要额外搭建消息代理集群（但优点是大于缺点的 ） 。

ZeroMQ 和 RabbitMQ/Kafka 不同，它只是一个异步消息库，在套接字的基础上提供了类似于消息代理的机制。使用 ZeroMQ 的话，需要对自己的业务代码进行改造，不利于服务解耦。

RabbitMQ 支持 AMQP（二进制），STOMP（文本），MQTT（二进制），HTTP（里面包装其他协议）等协议。Kafka 使用自己的协议。

Kafka 自身服务和消费者都需要依赖 Zookeeper。

RabbitMQ 在有大量消息堆积的情况下性能会下降，Kafka不会。毕竟AMQP设计的初衷不是用来持久化海量消息的，而Kafka一开始是用来处理海量日志的。

总的来说，RabbitMQ 和 Kafka 都是十分优秀的分布式的消息代理服务，只要合理部署，不作，基本上可以满足生产条件下的任何需求。

|         | ActiveMQ                                                                                                                                                                  | RabbitMQ                                                                                                         | RocketMq                                                                                                                                                                                 | ZeroMQ                   |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ |
| 关注度     | 高                                                                                                                                                                         | 高                                                                                                                | 中                                                                                                                                                                                        | 中                        |
| 成熟度     | 成熟                                                                                                                                                                        | 成熟                                                                                                               | 比较成熟                                                                                                                                                                                     | 不成熟                      |
| 所属社区/公司 | Apache                                                                                                                                                                    | Mozilla Public License                                                                                           | Alibaba                                                                                                                                                                                  |                          |
| 社区活跃度   | 高                                                                                                                                                                         | 高                                                                                                                | 中                                                                                                                                                                                        | 低                        |
| 文档      | 多                                                                                                                                                                         | 多                                                                                                                | 中                                                                                                                                                                                        | 中                        |
| 特点      | 功能齐全，被大量开源项目使用                                                                                                                                                            | 由于Erlang 语言的并发能力，性能很好                                                                                            | 各个环节分布式扩展设计，主从 HA；支持上万个队列；多种消费模式；性能很好                                                                                                                                                    | 低延时，高性能，最高 43万条消息每秒      |
| 授权方式    | 开源                                                                                                                                                                        | 开源                                                                                                               | 开源                                                                                                                                                                                       | 开源                       |
| 开发语言    | Java                                                                                                                                                                      | Erlang                                                                                                           | Java                                                                                                                                                                                     | C                        |
| 支持的协议   | OpenWire、 STOMP、 REST、XMPP、 AMQP                                                                                                                                          | AMQP                                                                                                             | 自己定义的一 套(社区提供 JMS--不成熟)                                                                                                                                                                  | TCP、UDP                  |
| 客户端支持语言 | Java、C、 C++、 Python、 PHP、 Perl、.net 等                                                                                                                                     | Java、C、 C++、 Python、 PHP、Perl 等                                                                                  | Java  C++（不成熟）                                                                                                                                                                           | python、 java、 php、.net 等 |
| 持久化     | 内存、文件、数据库                                                                                                                                                                 | 内存、文件                                                                                                            | 磁盘文件                                                                                                                                                                                     | 在消息发送端保存                 |
| 事务      | 支持                                                                                                                                                                        | 不支持                                                                                                              | 支持                                                                                                                                                                                       | 不支持                      |
| 集群      | 支持                                                                                                                                                                        | 支持                                                                                                               | 支持                                                                                                                                                                                       | 不支持                      |
| 负载均衡    | 支持                                                                                                                                                                        | 支持                                                                                                               | 支持                                                                                                                                                                                       | 不支持                      |
| 管理界面    | 一般                                                                                                                                                                        | 好                                                                                                                | 无社区有 web console  实现                                                                                                                                                                     | 无                        |
| 部署方式    | 独立、嵌入                                                                                                                                                                     | 独立                                                                                                               | 独立                                                                                                                                                                                       | 独立                       |
| 评价      | 优点：   成熟的产品，已经在很多公司得到应用（非大规模场景）。有较多的文档。各种协议支持较好，有多重语言的成熟的客户端； 缺点： 根据其他用户反馈，会出莫名其妙的问题，切会丢失消息。 其重心放到activemq6.0 产品—apollo 上去了，目前社区不活跃，且对 5.x 维护较少； Activemq 不适合用于上千个队列的应用场景 | 优点：  由于erlang语言的特性，mq 性能较好；管理界面较丰富，在互联网公司也有较大规模的应用；支持amqp系诶，有多中语言且支持 amqp 的客户端可用   缺点：  erlang语言难度较 大。集群不支持动态扩展。 | 优点：   模型简单，接口易用（JMS  的接口很多场合并不太实用）。在阿里大规模应用。目前支付宝中的余额宝等新兴产 品均使用rocketmq。集群规模大概在50 台左右，单日处理消息上百亿；性能非常好，可以大量堆 积消息在broker  中；支持多种消费，包括集群消费、广播消费等。开发度较活跃，版本更新很快。  缺点：  没有在 mq 核心中去实现JMS 等接口， |                          |

### 选择

针对消息中间件的选择可以从以下方面进行考虑：(主要对比ActiveMQ和RocketMQ)
   优先级：我们的项目对此需求不是特别明显，RocketMQ需要新建一个特殊队列来接收优先级高的队列，无法实现从0-65535这种细粒度的控制，ActiveMQ可以精细控制
    顺序：我们的消息总线中的消息应该都是无状态的，所以对消息的处理顺序没有严格的要求，如果有特殊要求的话可以在业务层进行控制，activeMQ无法保证严格的顺序，RocketMQ可以保证严格的消费顺序
  持久化：都支持
  稳定性：RoketMQ在稳定性上可能更值得信赖，支持多种集群方案，毕竟已经撑过几个双十一
 消息过滤：ActiveMQ仅支持在客户端消费的时候进行判断是否是自己需要的消息，RocketMQ可以在broker端进行过滤，对于我们的消息总线，这里可以节省大量的网络传输是否会有消息重发造成的重复消费：RocketMQ可以保证，ActiveMQ无法保证
 回溯消费：即重新将某一个时刻之前的消息重新消费一遍，我们对于这种需求应该很少，RocketMQ支持，ActiveMQ不支持（RocketMQ的队列是持久化到硬盘的，定期进行清除
     事务：都支持
 定时消费：RocketMQ支持
  消息堆积：就是当缓存消息的内存满了之后的解决方案，一种是丢弃策略，这种不会影响吞吐量，还有一种就是将消息持久化到磁盘，这种会影响吞吐量，在评估影响程度上，RocketMQ的成绩稍微好一点
 客户端不在线：RocketMQ可以在客户端上线后继续将未消费的消息推送到客户端
   目前比较活跃的几种MQ中间件产品的对比如下：（仅统计开源的项目）

## springboot整合RabbitMQ

[来源](https://www.cnblogs.com/haixiang/p/10959551.html)

### 在windows上使用RabbitMQ

需要安装erlang环境， 然后在RabbitMQ官网安装mq， mq下载页面有版本对照， 需要erlang和mq版本相对

### 交换机

　路由键：消息绑定到交换器上的规则。

　　消息根据规则由交换机将消息投递到相对应的队列。如果路由消息不匹配任何绑定，消息将进入黑洞。

　　交换机有四种：direct、fanout、topic和header。其中headers和direct交换器完全一致，但性能比较差，很少用。

- direct 交换机（直接类型交换机)  ： 如果路由键匹配，消息就会被投递到对应的队列。服务器必须实现direct类型交换器，包括一个空白字符串命名的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键.

- 　fanout交换器(扇出类型交换机 )：当发送一套消息到fanout交换器时，它会把消息投递给所有附加在此交换器上的队列。只需要简单的将队列绑定到该类型交换机上，该类型的交换机绑定队列时可以不指定路由键(**Routingkey**)
  
    当消息发送给该交换机后，它会将消息投递给与该交换机绑定的所**有队列**
  
    很像广播，每台子网内的机器都会获得一份消息，Fanout交换机转发消息是最快的

- 　topic交换器 (主题类型交换机 )：这类交换器可以使来自不同源头的消息能够达到同一队列。将路由键和某模式进行匹配。此时队列需要绑定某一个模式上。符号#匹配0个或多个单词，符号 *匹配一个单词。

### 队列

RabbitMQ的消费者和生产者都能创建队列，通过queue.declare方法来创建。如果消费者在同一信道上订阅了一个队列，则它不能在声明队列，必须先取消订阅后，将信道置为传输模式。消费者订阅和绑定时都需要队列名，如果你创建队列时没有设置名字，rabbit会自动声明一个队列名称，并在queue.declare命令中返回。

　　如果你创建一个已经存在的队列，那么rabbit将不做任何事情。rabbit的queue.declare可以检测队列是否存在，如果队列存在，则返回成功，不存在则返回错误。

　　由生产者还是由消费者创建队列？答案是双向的，原因是消费者不能订阅不存在的队列，而发布者不能发布到消息不存在的队列，这有可能会造成消息的丢失。当然也可以通过其它方式来控制未发布的消息，而让消费者一端负责创建队列。

　　队列存在的意义：

　　（1）、为消息提供住所，消息再次等待消费

　　（2）、对负载均衡来说，队列是绝佳的方案。只需附加一堆消费者，并让RabbitMQ以循环的方式均匀地分配发来的消息

　　（3）、队列是RabbitMQ中消息的最后重点（除非消息进入黑洞）

### 交换机和队列的关系

**Binding**： 绑定关系， 需要给交换机绑定队列，绑定时需要给一个路由键

**Routingkey** 队列和队列进行绑定时，需要指定路由键或通配符路由键 

大致流程：使用RabbitMQ前，首先需要根据业务来创建交换机和队列，创建完成后需要给交换机绑定队列（交换机和队列可以是多对多的关系），绑定队列时要指定具体的路由键或者通配符路由键

当生产者发送一条消息的时候，需要指定交换机和路由键，消息到达Broker后先转给刚才指定的交换机，交换机再根据路由键来决定把消息投递给与自己绑定的哪一个或哪一些队列，最后再由消费端来监听这些队列，消费处理对应的消息

### 消息回调

即 **消息确认 **（生产者推送消息成功，消费者接收消息成功 ） 

在配置确认回调，测试发现无法触发回调函数，那么存在原因也许是因为版本导致的配置项不起效 

在生产者（provider）中配置消息确认调用回调函数 

在配置中配置两个回调函数 ， ConfirmCallback, ReturnCallback

```java
package com.rabbitmq.config;

import org.springframework.amqp.core.ReturnedMessage;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author badpoone
 * @date 2022/2/27  16:27
 */
@Configuration
public class RabbitConfig {


    @Bean
    public RabbitTemplate createRabbitTemplate (ConnectionFactory connectionFactory){
        RabbitTemplate rabbitTemplate= new RabbitTemplate();
        rabbitTemplate.setConnectionFactory(connectionFactory);
        //开启Mandatory 才能开启回调函数 ， 无论消息推送结果为何都会强制调用回调函数
        rabbitTemplate.setMandatory(true);

        //设置rabbit确认回调
        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {
            @Override
            public void confirm(CorrelationData correlationData, boolean ack, String cause) {
                System.out.println("ConfirmCallback         相关情况"+correlationData);
                System.out.println("ConfirmCallback         确认情况"+ack);
                System.out.println("ConfirmCallback         原因"+cause);
            }
        });

        //设置返回回调  这里使用的2.6.3 版本的 spring-boot-starter-amqp  返回一个 ReturnedMessage 对象
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returned) {
                System.out.println("ReturnCallback          消息"     +returned.getMessage());
                System.out.println("ReturnCallback          回应码"    +returned.getReplyCode());
                System.out.println("ReturnCallback          回应消息"  +returned.getReplyText());
                System.out.println("ReturnCallback          交换机"    +returned.getExchange());
                System.out.println("ReturnCallback          路由键"    +returned.getRoutingKey());

            }

        });
        return rabbitTemplate;
    }
}
```

从总体情况分析， 推送消息存在四种情况： 

 ①消息推送到server，但是在server里找不到交换机
        ②消息推送到server，找到交换机了，但是没找到队列
        ③消息推送到sever，交换机和队列啥都没找到
        ④消息推送成功

## 消息队列中，如何保证消息的顺序性

消息顺序会错乱的两个场景 

- **RabbitMQ**：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。

- **Kafka**：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。

  消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞**多个线程来并发处理消息**。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。
