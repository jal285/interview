# 网络知识考点

[50道计网面试题](https://www.eet-china.com/mp/a68780.html)

图解 TCP/IP

## HTTP协议是无状态的

当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。简言之，服务器不会去记住你是谁，所以是无状态协议。

.

### Http请求的过程和原理

HTTP是一个基于TCP/IP协议来传递数据的超文本传输协议，传输的数据类型有HTML,图片等。以访问百度有例子，看下一次Http的请求过程吧

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-d58966fe4854169509511d6bfc90de9d.png)Http请求过程

1. 客户端进行DNS域名解析，得到对应的IP地址

2. 根据这个IP，找到对应的服务器建立连接（三次握手）

3. 建立TCP连接后发起HTTP请求（一个完整的http请求报文）

4. 服务器响应HTTP请求，客户端得到html代码

5. 客户端解析html代码，用html代码中的资源(如js,css,图片等等)渲染页面。

6. 服务器关闭TCP连接（四次挥手）

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-99845059382a3c88ea6190ef462d5432.png)

## HTTP/1.0 1.1 2.0 区别

**HTTP/1.0**默认是短连接，可以强制开启，HTTP/1.1默认长连接，HTTP/2.0采用**多路复用**

**HTTP/1.0**

* 默认使用**短连接**，每次请求都需要建立一个TCP连接。它可以设置`Connection: keep-alive` 这个字段，强制开启长连接。

**HTTP/1.1**

* 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用。

* 分块传输编码，即服务端没产生一块数据，就发送一块，用”流模式”取代”缓存模式”。

* 管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。

**HTTP/2.0**

* 二进制协议，1.1版本的头信息是文本（ASCII编码），数据体可以是文本或者二进制；2.0中，头信息和数据体都是二进制。

* 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。

* 报头压缩，HTTP协议不带有状态，每次请求都必须附上所有信息。Http/2.0引入了头信息压缩机制，使用gzip或compress压缩后再发送。

* 服务端推送，允许服务器未经请求，主动向客户端发送资源。

## POST和GET的区别

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-1d6684f23ca9fad8e14a636e9d2b3d36-16373755480976.png)

## forward和redirect的区别

* **直接转发方式（Forward）** ，客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。

* **间接转发方式（Redirect）** 实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。

直接转发:a请求b, b将请求转发给c, 无论转发是否成功都将告诉a

间接转发: a请求b, b让a找c

* Redirect 的工作原理：

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-cefd503ecf09d013ccca358f11037b83.png)

* forward 的工作原理

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-715a25ba54d8cfa72f52e05bc456f6fc.png)

## HTTP 长连接

思路: 这道题实际上是考察TCP长连接的知识点，HTTP的长连接实质是指TCP的长连接。至于什么时候超时，我们记住这几个参数如tcp\_keepalive\_time、tcp\_keepalive\_probes就好啦

什么是HTTP的长连接？

HTTP分为长连接和短连接，本质上说的是TCP的长短连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才具有真正的长连接和短连接这一说法哈。

TCP长连接可以复用一个TCP连接，来发起多次的HTTP请求，这样就可以减少资源消耗，比如一次请求HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。
如何设置长连接？

通过在头部（请求和响应头）设置Connection字段指定为keep-alive，HTTP/1.0协议支持，但是是默认关闭的，从HTTP/1.1以后，连接默认都是长连接。

什么时候会超时

```c
1. tcp_keepalive_intvl = 15
2. tcp_keepalive_probes = 5
3. tcp_keepalive_time = 1800
```

## HTTPS

\*\*公私钥,数字证书,解密,对称加密,非对称加密 \*\*

HTTPS=HTTP+SSL/TLS, 使用SSL/TLS对数据进行加密和解密,Http进行传输

* SSL，即Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。

* TLS，即Transport Layer Security(安全传输层协议)，它是SSL3.0的后续版本。

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-9c2878c02a4e5545681e7c7b478e7b8c.png)

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-2fc53ca265032a799cb042bef2328eff.png)

1. 客户端发起Https请求，连接到服务器的443端口。

2. 服务器必须要有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。

3. 服务器将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。

4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。

5. 客户端将公钥加密后的密钥发送到服务器。

6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。

7. 服务器将加密后的密文返回到客户端。

8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

## HTTP状态码301和302的区别

301: (永久性转移) 请求的网页以呗永久移动到新位置. 服务器返回此相应 时,会自动将请求者转到新位置

302: (暂时性转移) 服务器目前正从不同位置的网页响应请求,但请求者应继续使用原有位置进行以后的请求. 此代码与响应GET和HEAD请求的301代码类似, 会自动将请求者转到不同的位置

` 当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，打个比方说，我有一套房子，但是最近走亲戚去亲戚家住了，过两天我还回来的。而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的，就比如你的那套房子其实是租的，现在租期到了，你又在另一个地方找到了房子，之前租的房子不住了。`

## 什么是数字签字,什么是数字证书

## 对称加密与非对称加密区别

## DNS的解析过程

## CSRF攻击

跨站请求维造(Cross-site request forgery) 是一种挟制用户在当前已登陆的Web应用程序上执行非本意的操作的攻击方法

解决方案:

* 检查Referer字段

* 添加校验token

## 五层计算机网络体系结构中, 每一层对应的网络协议有哪些

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-ba1e2d8a01c7492d49d39cb93378550f.png)

## IP地址的分类

一般可以这么认为，IP地址=网络号+主机号。

1. 网络号：它标志主机所连接的网络地址表示属于互联网的哪一个网络。

2. 主机号：它标志主机地址表示其属于该网络中的哪一台主机。

IP地址分为A，B，C，D，E五大类：

* A类地址(1\~126)：以0开头，网络号占前8位，主机号占后面24位。

* B类地址(128\~191)：以10开头，网络号占前16位，主机号占后面16位。

* C类地址(192\~223)：以110开头，网络号占前24位，主机号占后面8位。

* D类地址(224\~239)：以1110开头，保留位多播地址。

* E类地址(240\~255)：以11110开头，保留位为将来使用

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-faa187d21caaf4e7283eb57118ab21dc.png)

## ARP协议的工作过程

ARP 协议协议，**Address Resolution Protocol**，地址解析协议，它是用于实现IP地址到MAC地址的映射。

​

```html
首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。

当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址；如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的IP地址。

网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。

源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
```

## IP地址,为什么还要用MAC地址

* 简而言之，标识网络中的一台计算机，比较常用的就是**IP地址和MAC地址**，但计算机的IP地址可由用户自行更改，管理起来就相对困难，而MAC地址不可更改，所以一般会把IP地址和MAC地址组合起来使用。

* 那只使用MAC地址不用IP地址行不行呢？不行的！因为最早就是MAC地址先出现的，并且当时并不用IP地址，只用MAC地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。

* 那为什么要用IP地址呢？是因为IP地址是和地域相关的，对于同一个子网上的设备，IP地址的前缀都是一样的，这样路由器通过IP地址的前缀就知道设备在在哪个子网上了，而只用MAC地址的话，路由器则需要记住每个MAC地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。

* IP地址可以比作为地址，MAC地址为收件人，在一次通信过程中，两者是缺一不可的。

## TCP和UDP分别对应的常见应用层协议

**基于TCP的应用层协议有：HTTP、FTP、SMTP、TELNET、SSH**

* **HTTP**：HyperText Transfer Protocol（超文本传输协议），默认端口80

* **FTP**: File Transfer Protocol (文件传输协议), 默认端口(20用于传输数据，21用于传输控制信息)

* **SMTP**: Simple Mail Transfer Protocol (简单邮件传输协议) ,默认端口25

* **TELNET**: Teletype over the Network (网络电传), 默认端口23

* **SSH**：Secure Shell（安全外壳协议），默认端口 22

**基于UDP的应用层协议：DNS、TFTP、SNMP**

* **DNS** : Domain Name Service (域名服务),默认端口 53

* **TFTP**: Trivial File Transfer Protocol (简单文件传输协议)，默认端口69

* **SNMP**：Simple Network Management Protocol（简单网络管理协议），通过UDP端口161接收，只有Trap信息采用UDP端口162。

## ping的原理

Packet Internet Groper, 是一种因特网包探索器,用于测试网络连接量的程序。Ping是工作在TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态

ping基于 \[ICMP] 协议工作

关于A ping B工作过程如下

1. ping通知系统，新建一个固定格式的ICMP请求数据包

2. ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层

3. IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包

4. 先获取目标机器B的MAC地址。

5. 数据链路层构建一个数据帧，目的地址是IP层传过来的**MAC地址**，源地址是本机的**MAC地址**

6. 机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。

7. 根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间

8. 最终显示结果有这几项：发送到目的主机的IP地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大& 平均值

## TCP报文段首部格式

需要记住其中的几个控制位

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/1460000039165596.png)

首部固定部分各字段意义如下：

* 1 - **源端口和目的端口**：各占 2 个字节，分别写入源端口和目的端口。IP 地址 + 端口号就可以确定一个进程地址

* 2 -序号/序列号
  
  （Sequense Number，SN）：在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。该字段表示本报文段所发送的数据的第一个字节的序号。
  
  初始序号称为 Init Sequense Number, ISN
  
  （序号/序列号这个字段很重要，大家留个印象，下文会详细讲解）
  
  例如，一报文段的序号是 101，共有 100 字节的数据。这就表明：本报文段的数据的第一个字节的序号是 101，最后一个字节的序号是 200。显然，下一个报文段的数据序号应当从 201 开始，即下一个报文段的序号字段值应为 201。

* 3 - **确认号 ack**：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。

* 4 - **数据偏移**（首部长度）：它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。

* 5 - **保留**：占 6 位，应置为 0，保留为今后使用。

**保留位的右边还有6个控制位**，**这是T'CP用来说明报文段性质的**

* 紧急位 URG
  
  ：当 URG = 1 时，表明此报文段中有紧急数据，是高优先级的数据，应尽快发送，不用在缓存中排队。该控制位需配合紧急指针使用（紧急指针指出本报文段中紧急数据的字节数）
  
  举个例子：我们需要取消一个已经发送了很长程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这个指令将存储在接收 TCP 的缓存末尾，只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程，这样做就无法实现立即中断。

* **确认 ACK**：仅当 ACK = 1 时确认号字段才有效，当 ACK = 0 时确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置为 1。

* **推送 PSH**：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程。而不用等到整个缓存都填满了后再向上交付。

* **复位 RST**：当 RST = 1 时，表明 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。

* 同步 SYN
  
  ：SYN = 1 表示这是一个连接请求或连接接受报文。
  
  当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 且 ACK = 1。

* **终止 FIN**：用来释放一个连接。当 FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。

## TCP三次握手

​    关于握手后过程和服务器丶客户端对应的状态都需要记住

TCp提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的就是同步连接双方的序列号和确认号并交换TCP窗口大小信息

流程图 ![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-eaaf3fdfd9c7a2b0390fa7a7973f2218.png)

​                                                                    *TCP三次握手*

* 第一次握手(SYN=1, seq=x)，发送完毕后，客户端就进入SYN\_SEND状态

* 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入SYN\_RCV状态。

* 第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态

## TCP四次挥手

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-8d9d9e5c274d6b4cc3deb1767d67d1f8.png)

​                                                                    *TCP四次挥手过程*

1. 第一次挥手(FIN=1，seq=u)，发送完毕后，客户端进入**FIN\_WAIT\_1**状态。

2. 第二次挥手(ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入**CLOSE\_WAIT**状态，客户端接收到这个确认包之后，进入**FIN\_WAIT\_2**状态。

3. 第三次挥手(FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入**LAST\_ACK**状态，等待来自客户端的最后一个ACK。

1.第四次挥手(ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入TIME\_WAIT状态，**等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后**，没有收到服务器端的ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入CLOSED状态。服务器端接收到这个确认包之后，关闭连接，进入CLOSED状态.

## TCP四次挥手过程中, 为什么需要等待2MSL,才进入CLOSED关闭状态

![img](../images/%E8%AE%A1%E7%BD%91%E9%9D%A2%E8%AF%95%E9%A2%98/MBXY-CR-44ee0cb73ea8397feb1977d138f8f995.png)

2MSL，**two Maximum Segment Lifetime**，即两个最大段生命周期。假设**主动发起挥手的是客户端**，那么需要2MSL的原因是：

## TCP的可靠性

1. 确认和重传机制
   
   * 建立连接时三次握手同步双方的”序列号+确认号+窗口大小信息“，MSS(最大传输数据段，取两者中较小的一方) 是确认重传、流量控制的基础
   
   * 传输过程中，如果数据量校验失败、丢包或延时，发送端重新传输数据

2. 数据排序
   
   * TCP有专门的序列号SN字段，可提供数据re-order （重发） 

3. 流量控制
   
   * 窗口和计时器的使用，TCP窗口中会指明双方能够接受的最大数据量

4. 拥塞控制
   
   ​    四个核心算法
   
   * 慢启动
   
   * 拥塞避免
   
   * 快速重传
   
   * 快速恢复
